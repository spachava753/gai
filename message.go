package gai

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
)

// Role represents what type a Message is
type Role uint

const (
	// User represents the user role in a list of messages
	User Role = iota

	// Assistant represents the assistant role in a list of messages.
	// A Message that has an Assistant role represents content generated
	// by the model
	Assistant

	// ToolResult represents the result of a tool execution.
	// A Message with this role contains the output from a tool that
	// was called during generation. This allows tool results to support
	// multiple Blocks of different Modalities
	ToolResult
)

// String returns the string representation of the role
func (r Role) String() string {
	switch r {
	case User:
		return "user"
	case Assistant:
		return "assistant"
	case ToolResult:
		return "tool result"
	default:
		return fmt.Sprintf("unknown role %d", r)
	}
}

// Modality represents the type of modality that a Block holds
// The default for Modality is a Text type
type Modality uint

const (
	Text Modality = iota
	Image
	Audio
	Video
)

// String returns the string representation of the modality
func (m Modality) String() string {
	switch m {
	case Text:
		return "text"
	case Image:
		return "image"
	case Audio:
		return "audio"
	case Video:
		return "video"
	default:
		return fmt.Sprintf("unknown modality %d", m)
	}
}

const (
	Content  = "content"
	Thinking = "thinking"
	ToolCall = "tool_call"
)

// Block represents a self-contained piece of a Message, meant to represent a "part" of a message.
// For example, if a message returned by a model contains audio and a tool call, the audio would
// be represented as one block, and the tool call another. Another example is if there are multiple
// tool calls in a response generated by a model, each tool call would be represented by single Block.
type Block struct {
	// ID is optional, it is commonly set when for ToolCall block types,
	// and sometimes for Content type blocks. An empty string means that the ID field
	// is not set
	ID string

	// BlockType is required, and if not set explicitly, the default value is of type Content.
	// - A Content BlockType represents unstructured content of single Modality, like text, images and audio
	// - A Thinking BlockType represents the thinking/reasoning a Generator produced
	// - A ToolCall BlockType represents a tool call by the model
	//
	// Note that a Generator can support more block types than the ones listed above,
	// the above block types are simply a common set of block types that a Generator can return.
	BlockType string

	// ModalityType represents the Modality of the content
	ModalityType Modality

	// MimeType represents the MIME type of the content.
	// Common values include "text/plain", "image/jpeg", "image/png", "audio/mp3", "video/mp4", etc.
	// If empty, defaults to "text/plain"
	MimeType string

	// Content represents the content of the block. It can be any type that implements fmt.Stringer.
	// For non-text modalities like images, audio, or video, the Content's String() method should
	// return base64 encoded data. The MimeType field should be set appropriately to indicate the
	// content type.
	Content fmt.Stringer

	// ExtraFields allows a Generator to store Generator-specific extra information that can used
	// in a later invocation
	ExtraFields map[string]interface{}
}

// Message represents a collection of blocks produced by the user or meant for the assistant.
type Message struct {
	// Role is required, and the default value of Role is User. However, for readability purposes,
	// it is recommended to always set the Role to User or Assistant and not rely on the zero value
	// to make it clear to the reader what type of Message it is
	Role Role

	// Blocks represents the collection of different blocks produced by the User or Assistant
	Blocks []Block

	ToolResultError bool
}

// Dialog represents a dialog between a User and Assistant
type Dialog []Message

// Str is a simple string type that implements fmt.Stringer
type Str string

func (s Str) String() string {
	return string(s)
}

// TextBlock creates a simple text content block.
// This is a convenience function for creating basic text blocks.
//
// Example:
//
//	block := TextBlock("Hello, world!")
func TextBlock(text string) Block {
	return Block{
		BlockType:    Content,
		ModalityType: Text,
		MimeType:     "text/plain",
		Content:      Str(text),
	}
}

// ImageBlock creates an image content block with the given base64-encoded data and MIME type.
// This is a convenience function for creating image blocks.
//
// Example:
//
//	block := ImageBlock(base64EncodedJpeg, "image/jpeg")
func ImageBlock(data []byte, mimeType string) Block {
	base64Data := base64.StdEncoding.EncodeToString(data)
	return Block{
		BlockType:    Content,
		ModalityType: Image,
		MimeType:     mimeType,
		Content:      Str(base64Data),
	}
}

// AudioBlock creates an audio content block with the given base64-encoded data and MIME type.
// This is a convenience function for creating audio blocks.
//
// Example:
//
//	block := AudioBlock(audioData, "audio/mp3")
func AudioBlock(data []byte, mimeType string) Block {
	base64Data := base64.StdEncoding.EncodeToString(data)
	return Block{
		BlockType:    Content,
		ModalityType: Audio,
		MimeType:     mimeType,
		Content:      Str(base64Data),
	}
}

const BlockFieldFilenameKey = "filename"

// PDFBlock creates a PDF content block with the given base64-encoded data and filename.
// This is a convenience function for creating PDF blocks compatible with all providers.
//
// PDFs are treated as a special type of image modality by model providers. The PDF is converted to a series
// of images at the provider API level. For OpenAI, supplying a filename is required for PDF file input.
//
// Example:
//
//	pdfData, _ := os.ReadFile("paper.pdf")
//	block := PDFBlock(pdfData, "paper.pdf")
func PDFBlock(data []byte, filename string) Block {
	base64Data := base64.StdEncoding.EncodeToString(data)
	return Block{
		BlockType:    Content,
		ModalityType: Image,
		MimeType:     "application/pdf",
		Content:      Str(base64Data),
		ExtraFields: map[string]interface{}{
			BlockFieldFilenameKey: filename,
		},
	}
}

// ToolCallBlock creates a tool call block with the given ID, tool name, and parameters.
// The parameters are automatically marshaled to JSON.
//
// Example:
//
//	block := ToolCallBlock("call_123", "get_weather", map[string]any{
//		"location": "New York",
//		"units": "fahrenheit",
//	})
func ToolCallBlock(id, toolName string, parameters map[string]any) (Block, error) {
	toolUse := ToolUseInput{
		Name:       toolName,
		Parameters: parameters,
	}

	data, err := json.Marshal(toolUse)
	if err != nil {
		return Block{}, fmt.Errorf("failed to marshal tool use: %w", err)
	}

	return Block{
		ID:           id,
		BlockType:    ToolCall,
		ModalityType: Text,
		MimeType:     "text/plain",
		Content:      Str(data),
	}, nil
}

// ToolResultMessage creates a message representing the result of a tool execution.
// This function constructs a Message with the ToolResult role and a single Block containing
// the tool execution results.
//
// Parameters:
//   - id: The identifier for the tool call, should match the original tool call ID
//   - modality: The modality of the content (Text, Image, Audio, or Video)
//   - mimeType: The MIME type of the content, e.g. "text/plain", "image/jpeg"
//   - content: The actual content of the tool result as a fmt.Stringer
//
// Returns a Message configured with ToolResult role and appropriate Block settings.
//
// Example:
//
//	result := ToolResultMessage("call_123", gai.Text, "text/plain", gai.Str("Temperature: 72°F"))
func ToolResultMessage(id string, modality Modality, mimeType string, content fmt.Stringer) Message {
	return Message{
		Role: ToolResult,
		Blocks: []Block{
			{
				ID:           id,
				BlockType:    Content,
				ModalityType: modality,
				MimeType:     mimeType,
				Content:      content,
			},
		},
	}
}

// TextToolResultMessage is a convenience function that creates a text-based tool result message.
// This is a shorthand for creating tool result messages with text content using the default
// "text/plain" MIME type.
//
// Parameters:
//   - id: The identifier for the tool call, should match the original tool call ID
//   - content: The text content of the tool result
//
// Returns a Message configured with ToolResult role and a single Text Block.
//
// Example:
//
//	result := TextToolResultMessage("call_123", "Temperature: 72°F")
func TextToolResultMessage(id string, content string) Message {
	return ToolResultMessage(id, Text, "text/plain", Str(content))
}
