package gai

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
)

// Role represents what type a Message is
type Role uint

const (
	// User represents the user role in a list of messages
	User Role = iota

	// Assistant represents the assistant role in a list of messages.
	// A Message that has an Assistant role represents content generated
	// by the model
	Assistant

	// ToolResult represents the result of a tool execution.
	// A Message with this role contains the output from a tool that
	// was called during generation. This allows tool results to support
	// multiple Blocks of different Modalities
	ToolResult
)

// String returns the string representation of the role
func (r Role) String() string {
	switch r {
	case User:
		return "user"
	case Assistant:
		return "assistant"
	case ToolResult:
		return "tool result"
	default:
		return fmt.Sprintf("unknown role %d", r)
	}
}

// Modality represents the type of modality that a Block holds
// The default for Modality is a Text type
type Modality uint

const (
	Text Modality = iota
	Image
	Audio
	Video
)

// String returns the string representation of the modality
func (m Modality) String() string {
	switch m {
	case Text:
		return "text"
	case Image:
		return "image"
	case Audio:
		return "audio"
	case Video:
		return "video"
	default:
		return fmt.Sprintf("unknown modality %d", m)
	}
}

const (
	// Content represents unstructured content of a single Modality, like text, images and audio.
	Content = "content"

	// Thinking represents the thinking/reasoning content a Generator produced.
	// When a block has this type, its ExtraFields will contain ThinkingExtraFieldGeneratorKey
	// to identify which generator produced the thinking content. This allows consumers to
	// handle thinking blocks differently based on their source (e.g., accessing Anthropic-specific
	// signature fields via AnthropicExtraFieldThinkingSignature).
	Thinking = "thinking"

	// ToolCall represents a tool call request by the model.
	ToolCall = "tool_call"

	// MetadataBlockType represents a block containing usage metadata.
	MetadataBlockType = "metadata"

	// ThinkingExtraFieldGeneratorKey is set in Block.ExtraFields for Thinking blocks to identify
	// which generator produced the thinking content. All generators that support thinking blocks
	// set this field automatically.
	//
	// The value is one of the ThinkingGenerator* constants (e.g., ThinkingGeneratorAnthropic).
	//
	// Example usage:
	//
	//	for _, block := range message.Blocks {
	//	    if block.BlockType == gai.Thinking {
	//	        if gen, ok := block.ExtraFields[gai.ThinkingExtraFieldGeneratorKey]; ok {
	//	            switch gen {
	//	            case gai.ThinkingGeneratorAnthropic:
	//	                // Access Anthropic-specific fields like AnthropicExtraFieldThinkingSignature
	//	            case gai.ThinkingGeneratorGemini:
	//	                // Access Gemini-specific fields like GeminiExtraFieldThoughtSignature
	//	            }
	//	        }
	//	    }
	//	}
	ThinkingExtraFieldGeneratorKey = "thinking_generator"

	// ThinkingGeneratorAnthropic identifies thinking blocks from the Anthropic generator.
	// Anthropic thinking blocks may also contain AnthropicExtraFieldThinkingSignature.
	ThinkingGeneratorAnthropic = "anthropic"

	// ThinkingGeneratorCerebras identifies thinking blocks from the Cerebras generator.
	ThinkingGeneratorCerebras = "cerebras"

	// ThinkingGeneratorGemini identifies thinking blocks from the Gemini generator.
	// Gemini thinking blocks may also contain GeminiExtraFieldThoughtSignature.
	ThinkingGeneratorGemini = "gemini"

	// ThinkingGeneratorOpenRouter identifies thinking blocks from the OpenRouter generator.
	// OpenRouter thinking blocks may also contain OpenRouterExtraFieldReasoningType,
	// OpenRouterExtraFieldReasoningFormat, OpenRouterExtraFieldReasoningIndex, and
	// OpenRouterExtraFieldReasoningSignature.
	ThinkingGeneratorOpenRouter = "openrouter"

	// ThinkingGeneratorResponses identifies thinking blocks from the OpenAI Responses generator.
	ThinkingGeneratorResponses = "responses"

	// ThinkingGeneratorZai identifies thinking blocks from the Zai generator.
	ThinkingGeneratorZai = "zai"
)

// Block represents a self-contained piece of a Message, meant to represent a "part" of a message.
// For example, if a message returned by a model contains audio and a tool call, the audio would
// be represented as one block, and the tool call another. Another example is if there are multiple
// tool calls in a response generated by a model, each tool call would be represented by single Block.
type Block struct {
	// ID is optional, it is commonly set when for ToolCall block types,
	// and sometimes for Content type blocks. An empty string means that the ID field
	// is not set
	ID string

	// BlockType is required, and if not set explicitly, the default value is of type Content.
	// - A Content BlockType represents unstructured content of single Modality, like text, images and audio
	// - A Thinking BlockType represents the thinking/reasoning a Generator produced
	// - A ToolCall BlockType represents a tool call by the model
	//
	// Note that a Generator can support more block types than the ones listed above,
	// the above block types are simply a common set of block types that a Generator can return.
	BlockType string

	// ModalityType represents the Modality of the content
	ModalityType Modality

	// MimeType represents the MIME type of the content.
	// Common values include "text/plain", "image/jpeg", "image/png", "audio/mp3", "video/mp4", etc.
	// If empty, defaults to "text/plain"
	MimeType string

	// Content represents the content of the block. It can be any type that implements fmt.Stringer.
	// For non-text modalities like images, audio, or video, the Content's String() method should
	// return base64 encoded data. The MimeType field should be set appropriately to indicate the
	// content type.
	Content fmt.Stringer

	// ExtraFields allows a Generator to store Generator-specific extra information that can be used
	// in a later invocation or for handling provider-specific features.
	//
	// Common fields include:
	//   - ThinkingExtraFieldGeneratorKey: Always set on Thinking blocks to identify the source generator
	//   - AnthropicExtraFieldThinkingSignature: Signature for Anthropic extended thinking blocks
	//   - GeminiExtraFieldThoughtSignature: Signature for Gemini thinking blocks
	//   - OpenRouterExtraFieldReasoningType/Format/Index/Signature: OpenRouter reasoning metadata
	//   - OpenAIExtraFieldImageWidth/Height/Detail: Image processing hints for OpenAI
	//   - BlockFieldFilenameKey: Filename for PDF blocks
	//
	// See each generator's documentation for provider-specific fields.
	ExtraFields map[string]interface{}
}

// Message represents a collection of blocks produced by the user or meant for the assistant.
type Message struct {
	// Role is required, and the default value of Role is User. However, for readability purposes,
	// it is recommended to always set the Role to User or Assistant and not rely on the zero value
	// to make it clear to the reader what type of Message it is
	Role Role

	// Blocks represents the collection of different blocks produced by the User or Assistant
	Blocks []Block

	// ToolResultError indicates whether the tool execution resulted in an error.
	// When true, the message content represents an error response from a tool call.
	// This is used by providers to properly format error responses in the API request.
	ToolResultError bool

	// ExtraFields allows storing additional message-level information that can be used
	// for provider-specific features or custom metadata. Unlike Block.ExtraFields which
	// stores block-specific data, this field is for information that applies to the
	// entire message.
	ExtraFields map[string]interface{}
}

// Dialog represents a dialog between a User and Assistant
type Dialog []Message

// Str is a simple string type that implements fmt.Stringer
type Str string

func (s Str) String() string {
	return string(s)
}

// TextBlock creates a simple text content block.
// This is a convenience function for creating basic text blocks.
//
// Example:
//
//	block := TextBlock("Hello, world!")
func TextBlock(text string) Block {
	return Block{
		BlockType:    Content,
		ModalityType: Text,
		MimeType:     "text/plain",
		Content:      Str(text),
	}
}

// MetadataBlock creates a Block containing usage metadata.
// The metadata parameter should contain metric information such as token counts,
// typically using keys like UsageMetricInputTokens and UsageMetricGenerationTokens.
//
// This block type is primarily used internally by streaming generators to emit
// usage information as the final block in a stream.
func MetadataBlock(metadata Metadata) Block {
	jsonData, err := json.Marshal(metadata)
	if err != nil {
		jsonData = []byte("{}")
	}

	return Block{
		BlockType:    MetadataBlockType,
		ModalityType: Text,
		MimeType:     "application/json",
		Content:      Str(jsonData),
	}
}

// ImageBlock creates an image content block with the given base64-encoded data and MIME type.
// This is a convenience function for creating image blocks.
//
// Example:
//
//	block := ImageBlock(base64EncodedJpeg, "image/jpeg")
func ImageBlock(data []byte, mimeType string) Block {
	base64Data := base64.StdEncoding.EncodeToString(data)
	return Block{
		BlockType:    Content,
		ModalityType: Image,
		MimeType:     mimeType,
		Content:      Str(base64Data),
	}
}

// AudioBlock creates an audio content block with the given base64-encoded data and MIME type.
// This is a convenience function for creating audio blocks.
//
// Example:
//
//	block := AudioBlock(audioData, "audio/mp3")
func AudioBlock(data []byte, mimeType string) Block {
	base64Data := base64.StdEncoding.EncodeToString(data)
	return Block{
		BlockType:    Content,
		ModalityType: Audio,
		MimeType:     mimeType,
		Content:      Str(base64Data),
	}
}

const BlockFieldFilenameKey = "filename"

// PDFBlock creates a PDF content block with the given base64-encoded data and filename.
// This is a convenience function for creating PDF blocks compatible with all providers.
//
// PDFs are treated as a special type of image modality by model providers. The PDF is converted to a series
// of images at the provider API level. For OpenAI, supplying a filename is required for PDF file input.
//
// Example:
//
//	pdfData, _ := os.ReadFile("paper.pdf")
//	block := PDFBlock(pdfData, "paper.pdf")
func PDFBlock(data []byte, filename string) Block {
	base64Data := base64.StdEncoding.EncodeToString(data)
	return Block{
		BlockType:    Content,
		ModalityType: Image,
		MimeType:     "application/pdf",
		Content:      Str(base64Data),
		ExtraFields: map[string]interface{}{
			BlockFieldFilenameKey: filename,
		},
	}
}

// ToolCallBlock creates a tool call block with the given ID, tool name, and parameters.
// The parameters are automatically marshaled to JSON.
//
// Example:
//
//	block := ToolCallBlock("call_123", "get_weather", map[string]any{
//		"location": "New York",
//		"units": "fahrenheit",
//	})
func ToolCallBlock(id, toolName string, parameters map[string]any) (Block, error) {
	toolUse := ToolCallInput{
		Name:       toolName,
		Parameters: parameters,
	}

	data, err := json.Marshal(toolUse)
	if err != nil {
		return Block{}, fmt.Errorf("failed to marshal tool use: %w", err)
	}

	return Block{
		ID:           id,
		BlockType:    ToolCall,
		ModalityType: Text,
		MimeType:     "text/plain",
		Content:      Str(data),
	}, nil
}

// ToolResultMessage creates a message representing the result of a tool execution.
// This function constructs a Message with the ToolResult role containing one or more
// content blocks. The tool call ID is automatically set on all provided blocks.
//
// Parameters:
//   - id: The identifier for the tool call, should match the original tool call ID
//   - blocks: One or more content blocks (use TextBlock, ImageBlock, PDFBlock, etc.)
//
// Returns a Message configured with ToolResult role and the provided blocks.
//
// Examples:
//
//	// Single text result
//	result := ToolResultMessage("call_123", TextBlock("Temperature: 72Â°F"))
//
//	// PDF with explanation
//	result := ToolResultMessage("call_123",
//	    TextBlock("Here's the generated report:"),
//	    PDFBlock(pdfData, "report.pdf"),
//	)
//
//	// Multiple images
//	result := ToolResultMessage("call_123",
//	    TextBlock("Found 3 matching charts:"),
//	    ImageBlock(chart1, "image/png"),
//	    ImageBlock(chart2, "image/png"),
//	)
func ToolResultMessage(id string, blocks ...Block) Message {
	// Set the ID on all blocks
	resultBlocks := make([]Block, len(blocks))
	for i, block := range blocks {
		resultBlocks[i] = block
		resultBlocks[i].ID = id
	}
	return Message{
		Role:   ToolResult,
		Blocks: resultBlocks,
	}
}
